# -*- coding: utf-8 -*-
"""Calculation function to collect dynamical matrix files from different hp.x calculations into a single folder."""

from aiida import orm
from aiida.engine import calcfunction
from aiida.plugins import CalculationFactory

HpCalculation = CalculationFactory('quantumespresso.hp')


@calcfunction
def collect_atomic_calculations(**kwargs):
    """Collect dynamical matrix files into a single folder.

    Each collected file gets a different number at the end, obtained from the input link, which corresponds to its place
    in the list of q-points originally generated by distribute_qpoints.

    :param kwargs: keys are the string representation of the hubbard atom index and the value is the corresponding
        retrieved folder object.
    :return: FolderData object containing the perturbation files of the computed HpBaseWorkChain
    """
    import os

    output_folder = HpCalculation.dirname_output
    output_folder_hp = HpCalculation.dirname_output_hubbard
    output_prefix = HpCalculation._prefix  # pylint: disable=protected-access

    # Initialize the merged folder, by creating the subdirectory for the perturbation files
    merged_folder = orm.FolderData()

    for link_label, retrieved_folder in sorted(kwargs.items()):
        atomic_site_index = link_label.lstrip('site_index_')
        filepath = os.path.join(output_folder_hp, '{}.chi.pert_{}.dat'.format(output_prefix, atomic_site_index))
        with retrieved_folder.open(filepath, 'rb') as handle:
            merged_folder.put_object_from_filelike(handle, filepath, mode='wb')

    # Currently the Hp code requires the .save folder that is written by the original
    # PwCalculation, for the final post-processing matrix collection step. It doesn't really need all
    # the information contained in that folder, and requiring it means, copying it from remote to a
    # local folder and then reuploading it to remote folder. This is unnecessarily heavy
    retrieved_folder = list(kwargs.values())[0]

    dirpath = os.path.join(output_folder, output_prefix + '.save')
    dirpath_src = retrieved_folder._repository._get_base_folder().get_abs_path(dirpath)  # pylint: disable=protected-access
    merged_folder.put_object_from_tree(dirpath_src, dirpath)

    filepath = os.path.join(output_folder, output_prefix + '.occup')
    with retrieved_folder.open(filepath, 'rb') as handle:
        merged_folder.put_object_from_filelike(handle, filepath, mode='wb')

    filepath = os.path.join(output_folder, output_prefix + '.paw')
    with retrieved_folder.open(filepath, 'rb') as handle:
        merged_folder.put_object_from_filelike(handle, filepath, mode='wb')

    return merged_folder
